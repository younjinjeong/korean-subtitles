1
00:00:04,660 --> 00:00:08,400
피보탈 제공 스프링 프리젠테이션
(자막: yjeong@pivotal.io)

2
00:00:09,680 --> 00:00:11,680
감사합니다. 멋지네요!

3
00:00:11,700 --> 00:00:13,700
행사에 발표되는 성공사례는 참 대단한데요 그 중에

4
00:00:13,700 --> 00:00:15,440
특히 앤드류의 발표 끝에 나오는것 같은

5
00:00:15,540 --> 00:00:17,860
"우리는 지금 채용중이에요"는 특별히 더 좋네요

6
00:00:17,860 --> 00:00:19,180
대단합니다

7
00:00:19,180 --> 00:00:20,780
네 이제 다음 연사로는

8
00:00:20,780 --> 00:00:22,480
페어로 발표합니다

9
00:00:22,580 --> 00:00:24,800
두분 다 "스프링 부트" 팀 소속이구요

10
00:00:24,800 --> 00:00:26,340
하지만

11
00:00:26,380 --> 00:00:28,700
다른 피보탈 사람들처럼 이분들 직업이 하나가 아닌거 같은데요

12
00:00:28,700 --> 00:00:29,760
아

13
00:00:29,980 --> 00:00:32,340
한분은 스프링 코어의 커미터도 하고 있고

14
00:00:32,360 --> 00:00:35,440
또 다른 분은 클라우드 파운드리의 커미터입니다

15
00:00:35,460 --> 00:00:37,460
그녀는 사실 스프링 시큐리티를 사용해서

16
00:00:37,480 --> 00:00:40,420
클라우드 파운드리의 보안 시스템을 구현했는데요

17
00:00:40,420 --> 00:00:41,660
바로 UAA 입니다.
(사용자 인증 및 어카운트 서비스)

18
00:00:41,660 --> 00:00:43,580
자 그럼 이제 이 두분을 박수로 맞아주세요

19
00:00:43,820 --> 00:00:47,420
스테파니 니콜과

20
00:00:47,560 --> 00:00:51,400
스프링원 키노트 무대에 처음 오르는 마드라 바베를 소개합니다

21
00:00:51,920 --> 00:00:56,840
[청중 박수와 함께 등장]

22
00:01:08,020 --> 00:01:11,620
방금 몇분 전 필 웹의 세션에서는 변화의 적응이 얼마나 중요한지,

23
00:01:11,620 --> 00:01:15,180
그리고 여러분이 어떻게 그 변화에 적응할 수 있는지

24
00:01:15,180 --> 00:01:16,840
스프링 부트가 '선택'에 어떤 도움을 주는지 들으셨습니다

25
00:01:17,140 --> 00:01:20,060
이 세션에서 우리는 이 새로운 선택에 대해

26
00:01:20,200 --> 00:01:24,020
스프링 프레임워크 5와 스프링 부트 2.0, 그리고 스프링 데이터의

27
00:01:24,120 --> 00:01:26,980
주요한 변경사항에 대해 모두 모아서 한꺼번에 보여드릴거에요

28
00:01:27,360 --> 00:01:30,920
음 그리고 슬라이드는 그만 보고 라이브 코딩을 보시죠

29
00:01:30,920 --> 00:01:31,840
넵

30
00:01:31,880 --> 00:01:34,100
라이브 코딩을 위한 새 프로젝트를 만들기 위해서

31
00:01:34,160 --> 00:01:37,320
가셔야할 곳은 바로 start.spring.io 입니다

32
00:01:37,700 --> 00:01:41,620
보시다시피 선택 가능한 수많은 의존성 내역들이 있는데요

33
00:01:42,280 --> 00:01:46,980
선택을 끝내고 나면 "프로젝트 생성" 버튼을 누르시면 되죠

34
00:01:47,020 --> 00:01:49,980
아무 문제가 없다면 zip 파일이 생성되어 다운로드가 진행되고

35
00:01:50,120 --> 00:01:52,600
어딘가에 zip파일의 압축을 해제하면

36
00:01:52,660 --> 00:01:54,940
여러분이 선호하는 IDE로 프로젝트를 시작할 수 있죠

37
00:01:55,120 --> 00:01:58,280
이 방법도 있지만 사실 IDE에서 전 과정을 진행할 수도 있습니다

38
00:01:58,500 --> 00:02:00,380
저는 IntelliJ를 사용할 예정입니다만

39
00:02:00,500 --> 00:02:03,560
이클립스나 넷빈스를 통해서도 가능합니다

40
00:02:05,000 --> 00:02:09,860
이 세션에서 우리는 완전 논-블러킹 리액티브 웹 애플리케이션을 만들 에정입니다

41
00:02:10,180 --> 00:02:14,680
아주 간단한 애플리케이션을 만들건데요

42
00:02:14,840 --> 00:02:20,240
레스토랑 리스트를 보여주고, 항목 필터를 적용하는 애플리케이션 입니다

43
00:02:21,240 --> 00:02:23,840
Java9 을 선택하구요

44
00:02:24,140 --> 00:02:26,420
가장 최신의 스프링 부트 버전을 선택하고

45
00:02:27,040 --> 00:02:29,520
Reactive Web 을 선택합니다

46
00:02:29,700 --> 00:02:32,740
그리고 DevTool 역시 추가할 건데요

47
00:02:33,020 --> 00:02:36,720
IDE에서 부트 앱을 구동할때 유용한 도구들을 제공하기 때문입니다

48
00:02:38,020 --> 00:02:40,240
음 그리고 약 2000개의 레스토랑 리스트를 제공할

49
00:02:40,240 --> 00:02:42,380
애플리케이션 이름을 '스프링원 플랫폼으로' 합니다

50
00:02:44,200 --> 00:02:47,760
보시다시피 IDE에서도 동일하게 필요한 기술을 '선택' 하실 수 있구요

51
00:02:47,920 --> 00:02:49,920
Zip 파일을 받아서

52
00:02:50,060 --> 00:02:52,220
IDE에서 바로 프로젝트를 열어 줍니다

53
00:02:52,440 --> 00:02:54,600
이제 시작할 준비가 된거죠

54
00:02:54,880 --> 00:02:58,160
레스토랑 앱이니까, 레스토랑 타입을 만들어야겠어요

55
00:02:58,280 --> 00:03:00,520
아니에요, 그게 처음이 아니죠

56
00:03:00,520 --> 00:03:01,840
아니라구요?

57
00:03:01,840 --> 00:03:03,500
네. 테스트를 먼저 작성해야죠

58
00:03:03,500 --> 00:03:04,880
맞네요 맞아 맞아 맞아

59
00:03:05,100 --> 00:03:08,740
[청중 웃으며 박수]

60
00:03:08,740 --> 00:03:10,160
그쵸? 사람들이 맞다고 하잖아요

61
00:03:10,180 --> 00:03:12,500
네 당신 말이 맞아요

62
00:03:14,740 --> 00:03:16,740
그래서 음,

63
00:03:17,640 --> 00:03:21,780
스프링 프레임워크 5에서는 '웹 테스트 클라이언트'가 제공되죠

64
00:03:21,780 --> 00:03:26,620
MVC Mock에 익숙하다면 비슷한 방법으로 사용할 수 있습니다

65
00:03:26,740 --> 00:03:29,760
다만 실제 클라이언트는 다양한 서버를 대상으로

66
00:03:29,900 --> 00:03:32,160
'라이브 인티그레이션 테스트'를 수행합니다

67
00:03:32,740 --> 00:03:34,740
음, 그렇지만 지금 우리가 하려는 것은 이게 아니잖아요?

68
00:03:34,920 --> 00:03:37,660
우리가 해야하는건 애플리케이션의 특정 부분에 대해

69
00:03:37,680 --> 00:03:41,260
즉 컨트롤러 부분에 집중된 테스트를 수행해야 해요

70
00:03:41,540 --> 00:03:46,640
좋아요. 그럼 스프링 부트 테스트를 웹 플럭스 테스트로 변경해요

71
00:03:46,680 --> 00:03:48,680
슬라이스 애노테이션이며,

72
00:03:48,680 --> 00:03:50,320
이걸 통해 여러분은

73
00:03:50,500 --> 00:03:53,580
기본적으로 리액티브 컨트롤러를 직접 테스트할 수 있습니다

74
00:03:53,700 --> 00:03:56,900
서버가 동작하지 않아도 말이죠. 좀 더 Mock MVC 같네요

75
00:03:57,660 --> 00:03:58,900
좋아요

76
00:03:59,100 --> 00:04:02,320
음 여기 empty 컨트롤러를 생성했구요

77
00:04:02,320 --> 00:04:04,020
여기다가 뭘 하면 좋을까요?

78
00:04:04,340 --> 00:04:08,520
음, API 엔드포인트로 /restourant 를 사용하도록 하죠

79
00:04:08,520 --> 00:04:09,900
좋아요. 그리고

80
00:04:10,020 --> 00:04:12,480
그리고 카테고리 필터를 적용할 수 있도록 하구요

81
00:04:12,480 --> 00:04:14,400
"가장 높은 가격"으로 하면 어떨까요?

82
00:04:14,400 --> 00:04:15,320
좋네요

83
00:04:15,740 --> 00:04:19,220
네. 그럼 이제 카테고리가 필요한데, 무엇을 사용할까요?

84
00:04:19,220 --> 00:04:20,180
초밥?

85
00:04:20,180 --> 00:04:21,600
네. 초밥이 좋겠어요

86
00:04:21,780 --> 00:04:23,780
좋아요 초밥, 가장 높은 가격은요?

87
00:04:24,320 --> 00:04:26,320
20달러

88
00:04:26,320 --> 00:04:28,260
그런 가격의 초밥은 없어요. 동작하지 않을거에요

89
00:04:28,260 --> 00:04:29,380
[청중 웃음]

90
00:04:29,380 --> 00:04:29,880
헛

91
00:04:29,900 --> 00:04:32,500
음 그래도 지금은 제 키노트니까 제가 원하는대로 할래요

92
00:04:33,600 --> 00:04:34,600
좋습니다

93
00:04:34,600 --> 00:04:36,180
이렇게 구성한 후에는

94
00:04:36,400 --> 00:04:40,120
응답할 것으로 예상되는 동작을 추가해야 하는데요

95
00:04:40,200 --> 00:04:43,120
이 API의 응답이 200을 리턴할 것이라고 예상하겠습니다

96
00:04:43,780 --> 00:04:46,000
음, 아마 동작하지 않을것 같은데요

97
00:04:46,020 --> 00:04:48,020
네 맞아요. 테스트는 아마 실패할거에요

98
00:04:48,140 --> 00:04:52,880
이 요청을 처리할 리퀘스트 매퍼가 아직 구현되지 않았으니까요

99
00:04:52,880 --> 00:04:54,660
보시다시피 404가 발생했죠

100
00:04:55,000 --> 00:04:59,160
네, 그래서 저는 이제 레스토랑 타입을 생성하구요

101
00:04:59,840 --> 00:05:01,840
아주 쉬운걸로요

102
00:05:02,620 --> 00:05:06,620
그리고 데이터가 필요하니까 레포지토리를 생성하겠습니다

103
00:05:07,760 --> 00:05:09,180
여기 보시다시피

104
00:05:09,260 --> 00:05:12,460
레포지토리 매퍼의 findAll 메서드는 flux를 리턴합니다

105
00:05:12,520 --> 00:05:14,800
이건 리액티브 애플리케이션이니까요

106
00:05:14,880 --> 00:05:16,960
현재 있는 데이터 그 자체를 리턴하는 대신

107
00:05:17,080 --> 00:05:20,880
조건에 맞는 데이터가 있을때 퍼블리셔를 통해 얻기를 원합니다

108
00:05:21,000 --> 00:05:23,000
그리고 여기 flux가 바로

109
00:05:23,080 --> 00:05:25,680
리액티브 스트림을 구현하는 퍼블리셔입니다

110
00:05:25,680 --> 00:05:27,460
프로젝트 리액터에서 제공되죠

111
00:05:28,340 --> 00:05:31,000
자 그럼 이제 이걸 컨트롤러에서 사용해 볼까요

112
00:05:31,120 --> 00:05:33,240
음 여기 이거

113
00:05:36,200 --> 00:05:38,200
레스토랑... 레포지토리 
[라이브 코딩중]

114
00:05:39,800 --> 00:05:42,000
그래서 다시 테스트로 돌아가 보면

115
00:05:42,000 --> 00:05:43,000
음..

116
00:05:43,000 --> 00:05:44,820
테스트는 실패할건데요 왜냐하면

117
00:05:44,860 --> 00:05:48,160
레스토랑 레포지토리가 컨텍스트에 없기 때문입니다

118
00:05:48,300 --> 00:05:51,420
기억하셔야할 것은 슬라이스 애노테이션은 전체가 아니라

119
00:05:51,420 --> 00:05:53,320
컨트롤러만 스캔한다는 점 입니다

120
00:05:53,780 --> 00:05:58,160
그래서 우린 이 테스트를 위해서 레포지토리가 필요한데요

121
00:05:58,160 --> 00:06:01,780
실제 데이터가 어디서 오는지 여부는 관계 없기 때문입니다

122
00:06:02,160 --> 00:06:04,280
레포지토리를 생성합시다

123
00:06:04,380 --> 00:06:07,340
여기에 @MockBean 을 사용할건데요

124
00:06:07,340 --> 00:06:09,200
@MockBean이 하는일은

125
00:06:09,260 --> 00:06:13,320
컨텍스트안에서 동일한 타입의 빈이 발견되면 이를 Mock으로 대체합니다

126
00:06:13,420 --> 00:06:16,900
이건 여러분의 테스트를 원하는대로 설정할 수 있도록 합니다

127
00:06:16,960 --> 00:06:19,760
그리고 그런 Bean이 없다면, 테스트가 하나 생성합니다

128
00:06:21,080 --> 00:06:24,280
음 동작을 위해 몇개의 레스토랑을 추가하구요

129
00:06:25,840 --> 00:06:29,440
이제 레포지토리를 설정합니다

130
00:06:29,920 --> 00:06:31,920
findAll이 호출되면

131
00:06:32,600 --> 00:06:36,180
샘플 레스토랑을 리턴하도록 합니다

132
00:06:38,240 --> 00:06:41,200
자 이제 우린, Assertion을 지정하는데

133
00:06:41,400 --> 00:06:43,800
제공된 데이터에서 조건에 맞는 초밥집은 하나죠

134
00:06:43,800 --> 00:06:45,400
20달러요

135
00:06:45,440 --> 00:06:47,440
맞습니다 하나밖에 없죠

136
00:06:48,100 --> 00:06:50,100
실제로 이런데는 없죠

137
00:06:53,140 --> 00:06:55,260
Susi2Go 입니다

138
00:06:56,400 --> 00:06:59,780
아 그리고 추가로 확실히 하고 싶은건

139
00:07:00,080 --> 00:07:02,520
리턴되는 배열이 단 하나의 값만 가진다는 점입니다

140
00:07:04,740 --> 00:07:06,740
이렇게요

141
00:07:06,860 --> 00:07:08,860
음, 역시 테스트는 실패할건데요

142
00:07:09,020 --> 00:07:11,460
다시 컨트롤러로 돌아가서

143
00:07:11,460 --> 00:07:13,160
GET 매핑을 추가합니다

144
00:07:13,320 --> 00:07:16,600
레스토랑에 대한 요청을 처리하죠

145
00:07:18,560 --> 00:07:22,420
음, 좋습니다. 이제 컨트롤러를 구현해 보도록 하죠

146
00:07:22,780 --> 00:07:27,180
findAll을 사용할 수 있는 레포지토리가 있구요. 이건 레스토랑 리스트를 리턴합니다

147
00:07:27,680 --> 00:07:30,180
이제 로직을 추가할건데

148
00:07:30,280 --> 00:07:32,280
이 케이스에 대해 필터링을 적용하는 로직입니다

149
00:07:32,280 --> 00:07:32,780
네 맞습니다

150
00:07:32,860 --> 00:07:35,820
프로젝트 리액터는 flux나 mono에 대해

151
00:07:35,920 --> 00:07:38,900
다양한 오퍼레이터를 제공하는데요

152
00:07:39,380 --> 00:07:42,500
이걸 Java8의 스트림 API로 생각하실 수도 있습니다만

153
00:07:42,680 --> 00:07:47,580
이걸 사용하면 여러분들은 스레드에 대한 고민 없이 비동기를 구현할 수 있는것이 장점입니다

154
00:07:48,500 --> 00:07:52,500
그리고 여기 보시면 다양한 오퍼레이터들을 연결해서 사용하는데요

155
00:07:52,720 --> 00:07:57,420
내부적으로는 리액터가 자동으로 최적의 조합을 찾아 사용합니다

156
00:07:58,280 --> 00:08:00,280
자 그럼 테스트를 실행해 볼까요

157
00:08:00,280 --> 00:08:02,120
동작하는지 봅시다

158
00:08:02,300 --> 00:08:06,380
음 초밥집을 찾았나요. 어 안되네요

159
00:08:06,960 --> 00:08:08,400
왜죠?

160
00:08:08,720 --> 00:08:11,020
400이네요. 뭐가 잘못된걸까요

161
00:08:11,660 --> 00:08:12,960
우~

162
00:08:12,960 --> 00:08:14,320
아하

163
00:08:14,320 --> 00:08:15,640
오케이

164
00:08:15,640 --> 00:08:16,920
[문제를 찾아 수정중]

165
00:08:16,980 --> 00:08:17,840
오케이

166
00:08:19,180 --> 00:08:21,180
테스트가 올바르게 동작하는지 먼저 보죠 / 네

167
00:08:22,360 --> 00:08:27,580
초밥집을 찾았구요. 관심이 있다면 주소는 나중에 알려드릴께요

168
00:08:27,580 --> 00:08:29,500
[일부 청중 웃음]

169
00:08:30,020 --> 00:08:32,120
네. 테스트는 통과했구요

170
00:08:32,160 --> 00:08:35,400
그건 좋은거지만, 실제로는 Mock 레포지트리를 사용한거죠

171
00:08:35,400 --> 00:08:36,340
하지만

172
00:08:36,400 --> 00:08:40,200
제 생각에는 실제 데이터 저장소를 사용할 필요가 있을것 같은데요

173
00:08:40,360 --> 00:08:44,560
스프링 데이터에서는 Redis나 MongoDB, CouchBase 및 카산드라 같은

174
00:08:44,780 --> 00:08:48,840
데이터 저장소에 리액티브를 지원하는 신기능이 추가 되었습니다

175
00:08:49,140 --> 00:08:53,380
완전한 논-블러킹 웹 애플리케이션을 구현할때 데이터 레포지트리에

176
00:08:53,540 --> 00:08:57,100
리액티브를 적용하는 것은 매우 중요합니다

177
00:08:57,520 --> 00:09:00,940
저장소에 있는 데이터가 항상 존재하며 즉시 제공된다고 확신할 수 없으며

178
00:09:01,240 --> 00:09:06,660
이런 상태에서 데이터를 참조하기 위해 스레드가  대기상태에 있는건 원하는 동작이 아닐겁니다

179
00:09:07,140 --> 00:09:09,940
부트에 적용된 새로운 기술은 '스타터'를 통해 지원되는데

180
00:09:10,080 --> 00:09:15,040
이들 중 하나인 MongoDB 스타터를 의존성에 추가하겠습니다

181
00:09:15,420 --> 00:09:17,420
음..

182
00:09:17,820 --> 00:09:19,820
스프링 부트 스타터

183
00:09:19,980 --> 00:09:21,980
어, 'o'를 너무 많이 썼네요

184
00:09:23,320 --> 00:09:25,900
맨 뒤에 보면 'reactive'가 더해졌는데

185
00:09:25,940 --> 00:09:28,880
이건 MongoDB의 리액티브 드라이버를 의미합니다

186
00:09:29,120 --> 00:09:32,680
이 의존성을 추가함으로서 저는 스프링 데이터의 강력한 기능을 바로 사용할 수 있습니다

187
00:09:32,760 --> 00:09:36,380
이 부분을 삭제할 수 있는데, 왜냐면 이미 구현되었기 때문입니다

188
00:09:36,580 --> 00:09:40,100
대신 저는 표준 스프링 데이터 레포지트리를 만들면 되는거죠

189
00:09:40,700 --> 00:09:43,360
음 extends 를 사용해서

190
00:09:44,340 --> 00:09:46,340
리액티브 CRUD 레포지토리를 만들고

191
00:09:46,540 --> 00:09:49,760
PK의 타입을 지정합니다.
(Primary Key)

192
00:09:52,180 --> 00:09:53,740
음 대단하네요

193
00:09:53,740 --> 00:09:58,520
기억하셔야 할 점은 데이터는 엘레먼트의 컬렉션으로 응답되거나

194
00:09:58,700 --> 00:10:01,360
또는 무한의 스트림으로 응답될 수 있습니다

195
00:10:01,580 --> 00:10:05,600
중요한점은 언제나 데이터에 무엇을 할지 정의할 수 있으며

196
00:10:05,620 --> 00:10:10,320
Java8 스트림에서 오퍼레이터를 정의하는것과 같습니다

197
00:10:10,680 --> 00:10:13,320
좋습니다. 이를 도큐먼트로서 처리하죠

198
00:10:13,320 --> 00:10:16,180
Id가 설정 되었는지 확인하구요

199
00:10:17,880 --> 00:10:21,640
이제 컨트롤러에 필터를 직접 추가하는 대신

200
00:10:21,700 --> 00:10:24,120
저장소가 우리 대신 필터를 수행하도록 만들어 봅시다

201
00:10:24,320 --> 00:10:28,200
지금까지와 마찬가지로 여러분은 익숙한 프로그래밍 모델을 써서

202
00:10:28,200 --> 00:10:31,960
쿼리와 매칭되는 레스토랑의 리스트를 퍼블리싱할 수 있습니다

203
00:10:32,060 --> 00:10:34,880
그리고 이건 레포지트리에서 직접 처리할 수 있습니다

204
00:10:34,900 --> 00:10:40,660
findByCategoryAndPricePerPersonLessThan

205
00:10:41,640 --> 00:10:46,240
음 그리고 저는 여기에 카테고리를 적용합니다

206
00:10:46,240 --> 00:10:48,100
그리고 가장 높은 가격도요

207
00:10:48,660 --> 00:10:50,660
여기까지 하고 나면

208
00:10:50,740 --> 00:10:53,360
저를 위해서 쿼리가 자동으로 생성되구요

209
00:10:53,360 --> 00:10:55,340
테스트로서 가져다가 사용할 수 있습니다

210
00:10:55,540 --> 00:10:58,220
아 죄송합니다. 디코드의 일부죠

211
00:11:01,360 --> 00:11:03,940
카테고리와 음.. 가격

212
00:11:04,200 --> 00:11:07,200
컨트롤러에서 이런 동작을 구현하는 대신,

213
00:11:07,340 --> 00:11:10,060
리포지트리에서 대신 필터를 처리해 주는 것이죠

214
00:11:11,320 --> 00:11:13,320
대단해요!

215
00:11:13,360 --> 00:11:15,360
자 이제 우린 데이터 레포지트리를 만들었고

216
00:11:15,460 --> 00:11:19,240
사실 우린 아직 앱 만들기를 시작한건 아닙니다

217
00:11:19,240 --> 00:11:20,860
테스트를 만들었죠

218
00:11:20,860 --> 00:11:22,160
테스트 코드요

219
00:11:22,180 --> 00:11:26,660
자 그럼 이제부터 MongoDB 인스턴스의 데이터를 참조하는 앱을 만들어 보겠습니다

220
00:11:27,420 --> 00:11:30,180
제 랩탑에는 지금 MongoDB가 동작하고 있구요

221
00:11:30,180 --> 00:11:33,340
제가 직접 설정한 것은 아무것도 없는데, 이는 스프링 부트 애플리케이션이

222
00:11:33,340 --> 00:11:35,900
로컬 머신에서 동작하는 인스턴스를 찾아 자동으로 설정합니다

223
00:11:36,140 --> 00:11:38,740
자 그럼 이제 우리 애플리케이션을 직접 호출해 보겠습니다

224
00:11:39,700 --> 00:11:44,480
음, 초밥집 대신 패스트푸드 음식점을 찾아보겠습니다

225
00:11:45,220 --> 00:11:48,560
오, 여기 좋은게 있네요. '버거 스프링'

226
00:11:49,080 --> 00:11:51,080
'켄터키 플럭스 치킨'

227
00:11:51,100 --> 00:11:54,200
어, 사실 저는 'jack in the flux'가 마음에 드는데요

228
00:11:54,600 --> 00:11:57,200
오늘 저녁에 예약 가능한 자리가 있는지 궁금하네요

229
00:11:57,380 --> 00:11:59,780
좋아요. 그럼 데모를 더 진행해 보죠

230
00:11:59,820 --> 00:12:03,280
음 여기 8081포트로 동작하는 다른 서비스가 하나 더 있는데요

231
00:12:03,280 --> 00:12:04,940
이건 음

232
00:12:04,960 --> 00:12:08,540
이 8081에서 동작하고 있는 서비스를 호출해 보도록 하겠습니다

233
00:12:08,860 --> 00:12:10,860
음.. 레스토랑..

234
00:12:12,360 --> 00:12:14,760
요청을 이렇게... 음 '섬띵' 이라고 할까요 '섬띵'

235
00:12:15,080 --> 00:12:17,080
오늘 영업을 하는지 조회합니다

236
00:12:18,120 --> 00:12:20,120
보시다시피 응답에 시간이 좀 걸리는데요

237
00:12:20,240 --> 00:12:23,380
데모 애플리케이션은 이 8081에 동작하는 백엔드 서비스에 접근해서

238
00:12:23,380 --> 00:12:27,620
해당 레스토랑이 오늘 영업을 하는지의 여부를 응답합니다

239
00:12:27,880 --> 00:12:31,920
이 서비스가 항상 즉시 응답한다고 볼 수 없기 때문에

240
00:12:31,920 --> 00:12:34,420
데이터가 유입되는 대로 스트림 처리를 할거구요

241
00:12:34,500 --> 00:12:39,340
응답을 처리하기 위해 스레드가 블럭이나 대기 상태에 머물지 않게 합니다

242
00:12:40,880 --> 00:12:45,660
음, 이걸 위해서 컨트롤러에 새로운 기능을 구현해야 하는데

243
00:12:45,880 --> 00:12:48,580
8081 포트에서 동작하고 있는 서비스에 접근해야 합니다

244
00:12:48,780 --> 00:12:51,660
이 기능의 구현에 아마도 여러분은 REST 템플릿을 떠올리시겠지만

245
00:12:51,660 --> 00:12:53,600
음 원하신다면

246
00:12:53,640 --> 00:12:56,280
rest 템플릿을 컴포넌트에 추가하고

247
00:12:56,280 --> 00:12:58,860
스프링 부트 REST 템플릿 빌더를 인젝트 하실수 있죠

248
00:12:59,020 --> 00:13:01,660
이건 자동 설정 정보를 담고 있으며

249
00:13:01,660 --> 00:13:03,480
필요하다면 여러분의 입맛에 맞게 바꿀수도 있을겁니다

250
00:13:03,760 --> 00:13:08,820
또는 자주 사용하는 케이스에 대비해서 빌더를 수정할 수도 있을겁니다

251
00:13:08,840 --> 00:13:10,840
그치만 우린 그거 여기서 안할거에요

252
00:13:10,840 --> 00:13:12,340
REST템플릿을 사용하는 방법 말에요

253
00:13:12,460 --> 00:13:15,780
맞아요. 우린 지금 논-블러킹 리액티브 애플리케이션을 만들고 있고

254
00:13:15,820 --> 00:13:18,540
REST템플릿은 블러킹 API죠

255
00:13:18,900 --> 00:13:21,420
따라서 이 요청을 처리하는데 있어서

256
00:13:21,440 --> 00:13:24,160
블러킹의 방법은 하나도 사용하지 않을 예정이니까요

257
00:13:24,640 --> 00:13:27,300
음 그리고 우린 데이터를 스트림 처리해야 해요

258
00:13:27,440 --> 00:13:29,440
REST 템플릿으로는 할 수 없는 일이죠

259
00:13:29,740 --> 00:13:33,840
그래서 여기에 논-블러킹 리액티브 웹 클라이언트를 사용할거에요

260
00:13:33,880 --> 00:13:35,880
웹 클라이언트는

261
00:13:35,980 --> 00:13:39,220
스프링 부트를 통해 기존과 유사한 개발 방식을 제공하는데

262
00:13:39,360 --> 00:13:41,800
'웹 클라이언트 빌더'를 주입하실 수 있습니다

263
00:13:41,940 --> 00:13:43,940
REST 템플릿 빌더를 사용할때처럼

264
00:13:44,160 --> 00:13:48,920
스프링 부트가 감지한 모든 설정 및 여러분의 커스텀 설정이 모두 포함 됩니다

265
00:13:50,220 --> 00:13:54,720
이 데모의 경우에 제가 빌더에 직접 제공하는 설정은

266
00:13:54,720 --> 00:13:58,720
8081에서 동작하는 서비스의 주소입니다

267
00:14:00,020 --> 00:14:03,340
음 더 진행해 보면, 새로운 매핑을 추가하구요

268
00:14:04,540 --> 00:14:07,980
이 매핑이 리턴하는 것은 사실 스트림인데

269
00:14:08,180 --> 00:14:11,680
방금 설명한대로 JSON 스트림이구요

270
00:14:11,980 --> 00:14:17,140
인풋 스트림이 레스토랑이니까, 타입을 추가하고

271
00:14:18,980 --> 00:14:23,680
그리고 이 타입은 기본적으로 여기 보시는 JSON과 동일한 내용을 포함합니다

272
00:14:26,360 --> 00:14:29,600
아 좋습니다. 데모를 더 완성해 보자면

273
00:14:29,740 --> 00:14:33,200
모든 레스토랑에 대한 정보가 이미 등록되어 있다고 하고

274
00:14:33,260 --> 00:14:37,320
이 레스토랑들에 오늘밤 예약이 가능한지 서비스에 조회를 해 보도록 합니다

275
00:14:37,760 --> 00:14:41,560
이 동작을 위해 사용할 오퍼레이터는 바로 flatMap 입니다

276
00:14:41,620 --> 00:14:44,420
flatMap에 대한 컨셉은 사실 새로운 것이 아닌데요

277
00:14:44,540 --> 00:14:47,060
Java 8 스트림에서도 제공되고 있구요

278
00:14:47,100 --> 00:14:52,760
하지만 여기 보시는 flatMap은 비동기 nested 동작으로 생각하실 수 있는데

279
00:14:53,100 --> 00:14:55,780
이 경우에 먼저 레스토랑이 열었는지 확인을 하는

280
00:14:55,780 --> 00:14:58,580
이 부분이 비동기로 동작을 하고

281
00:14:58,840 --> 00:15:06,760
마지막에는 flatMap이 nested로 리턴된 모든 퍼블리셔에 대해 단일 퍼블리셔를 생성합니다

282
00:15:07,180 --> 00:15:10,340
여기에 getAvailability 메서드가 있는데

283
00:15:10,440 --> 00:15:13,720
레스토랑 리스트를 받아서 예약 가능한 레스토랑을 Mono로 리턴합니다

284
00:15:13,820 --> 00:15:17,680
이 Mono는 하나의 엘레먼트만 리턴할때 자주 사용하는 퍼블리셔 타입입니다

285
00:15:17,860 --> 00:15:22,380
Flux는 1개에 대해 많은 응답을, Mono는 한개 또는 0를 응답합니다

286
00:15:22,640 --> 00:15:26,620
이 데모에서 레스토랑의 가용 여부는 flux를 사용하고 있지만

287
00:15:26,620 --> 00:15:27,700
우리가 하고 싶은건

288
00:15:27,720 --> 00:15:30,880
단 하나의 예약 가능한 레스토랑 입니다

289
00:15:30,900 --> 00:15:33,940
그래서 여기에 filter 오퍼레이터를 사용합니다

290
00:15:34,700 --> 00:15:36,900
isAvailable flag가 있죠

291
00:15:37,360 --> 00:15:40,520
그리고 말씀 드렸듯이, 이들 중 '일부' 레스토랑만 필요합니다

292
00:15:40,520 --> 00:15:44,540
이런 동작을 위해 리액터에서는 'take' 오퍼레이터를 제공하는데

293
00:15:44,580 --> 00:15:49,160
take오퍼레이터에서는 여러분이 원하는 숫자를 지정할 수 있습니다

294
00:15:49,160 --> 00:15:50,260
3개로 할께요

295
00:15:50,260 --> 00:15:53,740
또는 특정 시간을 지정해서

296
00:15:53,900 --> 00:15:56,680
지정된 시간내에 응답 받은 데이터를 리턴할 수도 있습니다

297
00:15:56,880 --> 00:16:00,740
여러분은 여기에서 리액터의 강력함을 보실 수 있는데요

298
00:16:00,860 --> 00:16:04,900
이 모든 동작에 논-블러킹 비동기를 적용할 수 있는데

299
00:16:04,900 --> 00:16:08,840
우리가 스레드를 직접 통제할 필요가 없어지는 것입니다

300
00:16:09,020 --> 00:16:14,760
필요한 것을 지정하면 나머지는 리액터가 가장 효율적인 방법으로 처리하는 것이죠

301
00:16:15,740 --> 00:16:17,740
좋습니다. 이제 동작하는지 보죠

302
00:16:18,240 --> 00:16:20,240
음 여기 어딘가 있을텐데요

303
00:16:20,560 --> 00:16:22,560
아 여기 있네요

304
00:16:25,280 --> 00:16:28,460
보시다시피 데이터가 스트림되고 있습니다

305
00:16:28,460 --> 00:16:30,300
다시 호출해 보면

306
00:16:30,500 --> 00:16:33,120
take에서 지정한 대로 3개에서 멈추는것을 보실 수 있습니다

307
00:16:34,620 --> 00:16:37,440
오, 'jack in the flux' 는 오늘 영업하지 않는군요

308
00:16:38,120 --> 00:16:40,860
아, 네

309
00:16:41,220 --> 00:16:46,040
지금까지 여러분에게 어떤 웹 스택을 사용할 수 있는지 말씀드렸어요

310
00:16:46,200 --> 00:16:49,780
우리가 실제로 사용한 것은 스프링 5에서 새롭게 지원하는

311
00:16:49,900 --> 00:16:52,680
스프링 웹 플럭스 프레임워크 입니다

312
00:16:52,880 --> 00:16:55,340
그리고 이건 스프링 MVC와 함께 제공됩니다

313
00:16:55,340 --> 00:16:58,780
그리고 스프링 웹 플럭스는 기본으로 Netty를 사용합니다

314
00:16:58,780 --> 00:17:00,760
비동기 런타임이죠

315
00:17:00,860 --> 00:17:03,640
이전에 기본으로 사용되는 톰캣이나 Jett

316
00:17:03,740 --> 00:17:07,000
톰캣과 제티 역시 사용하실 수 있습니다

317
00:17:07,120 --> 00:17:09,540
여러분은 원하는대로 선택해서 사용할 수 있습니다

318
00:17:10,060 --> 00:17:13,700
톰캣과 제티를 웹 플럭스에 사용할때 아셔야 할 것은

319
00:17:13,800 --> 00:17:17,780
서블릿 API의 어떠한 블러킹 파트도 사용하지 않는다는 점입니다

320
00:17:17,940 --> 00:17:22,700
대신 서블릿 3.1의 논블러킹 API를 사용하고 있습니다

321
00:17:23,040 --> 00:17:25,040
이 부분에 정보가 더 필요하신 분들은

322
00:17:25,140 --> 00:17:29,980
톰캣 커미터가 진행하는 세션이 있으니 들어보시기 바랍니다

323
00:17:31,820 --> 00:17:36,400
보셨다시피 여기서 완전한 논-블러킹 리액티브 애플리케이션을 구현했지만

324
00:17:36,580 --> 00:17:42,280
우린 여러분이 스프링 MVC 역시 사용을 원한다는 점을 알고 있습니다

325
00:17:42,400 --> 00:17:46,460
하지만 MVC를 사용하는 경우에도 웹 클라이언트나

326
00:17:46,540 --> 00:17:48,540
리액티브 데이터 레포지트리를 사용하고 싶을수도 있습니다

327
00:17:48,760 --> 00:17:53,460
음, 우리 애플리케이션을 스프링 MVC 로 바꿔보는건 어떨까요

328
00:17:54,060 --> 00:17:55,520
잠깐... 뭐라구요?

329
00:17:55,880 --> 00:17:57,880
네, 해보자구요 
[청중 웃음]

330
00:17:58,020 --> 00:18:00,020
우리 10분 밖에 없어요

331
00:18:00,620 --> 00:18:03,320
절 믿어봐요. 코드를 바꿀 필요는 없어요

332
00:18:03,420 --> 00:18:05,420
그래요 
[청중 웃음]

333
00:18:05,900 --> 00:18:10,860
음, 그럼 의존성에 스프링 MVC를 제공하는 웹 스타터를 추가하고

334
00:18:10,860 --> 00:18:12,740
우리 애플리케이션을 재시작해 봅시다

335
00:18:13,660 --> 00:18:17,960
이 경우 기본 런타임은 톰캣이 되죠. 아시다시피요

336
00:18:21,020 --> 00:18:23,020
무슨일이 벌어지는지 봅시다

337
00:18:26,860 --> 00:18:28,860
네, 톰캣으로 동작하고 있구요

338
00:18:29,680 --> 00:18:31,680
뒤에 앉으신 분들을 위해 확대합니다

339
00:18:37,200 --> 00:18:39,200
동작하네요

340
00:18:39,200 --> 00:18:40,740
좋아요

341
00:18:40,780 --> 00:18:43,180
그럼 대체 뭐가 달라진거죠?

342
00:18:43,540 --> 00:18:45,540
지금 방금 여러분이 보신것은

343
00:18:45,660 --> 00:18:47,960
일반적인 MVC 스프링 애플리케이션이지만

344
00:18:47,980 --> 00:18:52,540
리액티브 웹 클라이언트와 리액티브 데이터 레포지트리를 사용합니다

345
00:18:53,160 --> 00:18:56,220
아직 동작하지만, 이전과의 차이점은

346
00:18:56,280 --> 00:18:59,680
바로 블러킹 I/O를 사용한다는 점입니다

347
00:18:59,680 --> 00:19:02,280
HTTP 요청에 대한 응답을 처리하기 위해서 말이죠

348
00:19:02,300 --> 00:19:08,660
이걸 웹 플럭스로 변경하면 모든 블러킹 I/O를 사용하지 않게 되는 것이며

349
00:19:08,820 --> 00:19:11,780
내부적으로 완전히 다른 일관성 모델을 사용합니다

350
00:19:11,880 --> 00:19:15,640
당연히 웹 플럭스를 사용하는 경우에만 제공되는 기능들이 있구요

351
00:19:15,860 --> 00:19:20,140
하지만 말씀드렸듯, 아마 여러분은 모든 부분에 리액티브 사용을 원치 않을수도 있습니다

352
00:19:20,340 --> 00:19:24,200
또는 기존의 스프링 MVC애플리케이션을 계속 사용하고 싶을수도 있습니다

353
00:19:24,260 --> 00:19:28,540
이것이 스프링이 여러분에게 드리는 선택입니다

354
00:19:28,620 --> 00:19:31,120
어떤 선택을 하시던 저희 스프링팀은 두가지 모두를 지원합니다

355
00:19:32,200 --> 00:19:36,280
만약 어떤 선택의 옵션이 더 있는지 알고 싶으시다면

356
00:19:36,280 --> 00:19:40,300
Russon이 진행하는 세션이 오늘 있으니 들어보세요

357
00:19:41,740 --> 00:19:46,420
백엔드 서비스를 통해서 선택할 수 있는 부분에 대해 말씀드렸는데

358
00:19:46,440 --> 00:19:49,240
얼른 나머지를 구현해 보도록 합시다

359
00:19:49,380 --> 00:19:54,120
이 백엔드 애플리케이션은 코틀린으로 쓰여진 앱이구요

360
00:19:54,560 --> 00:19:59,220
코드를 더 자세히 보고 싶으신 분들을 위해 세션이 끝나면 공개하도록 하겠습니다

361
00:19:59,300 --> 00:20:02,920
애노테이션 기반의 컨트롤러를 사용하는 대신

362
00:20:02,960 --> 00:20:05,400
프락시 팬을 사용하고 있는데

363
00:20:05,480 --> 00:20:09,600
이 경우에 여러분은 라우팅을 프로그래매틱하게 제어할 수 있습니다

364
00:20:09,600 --> 00:20:11,480
이 경우 단 하나의 엔트리만 가지고 있으며

365
00:20:11,600 --> 00:20:15,520
보시는 것이 레스토랑의 가용성 여부를 확인하는 엔드포인트구요

366
00:20:15,840 --> 00:20:18,220
이는 핸들러를 호출하는데

367
00:20:18,380 --> 00:20:25,400
핸들러는 서버의 요청을 처리하고 응답하는 간단한 함수로 구성되어 있습니다

368
00:20:25,440 --> 00:20:27,440
여기 보시다시피

369
00:20:27,520 --> 00:20:29,840
무지 엄청 똑똑한 randomThinkTime이 적용되어 있죠

370
00:20:31,840 --> 00:20:34,900
자 그럼 다시 돌아가서

371
00:20:35,320 --> 00:20:38,440
우리의 MVC 앱을 바꿔 보도록 하겠습니다

372
00:20:38,440 --> 00:20:40,160
웹 플럭스 앱이죠  죄송합니다

373
00:20:41,260 --> 00:20:43,860
몇가지 기능을 더해볼 수도 있는데요

374
00:20:43,860 --> 00:20:45,380
그러죠 음

375
00:20:45,380 --> 00:20:47,220
액츄에이터를 더해보면 어떨까요?

376
00:20:47,300 --> 00:20:51,040
스프링 MVC에서 제공되었던 액츄에이터 정말 사랑해요

377
00:20:51,480 --> 00:20:54,100
스프링 웹 플럭스에서도 사용 가능할까요?

378
00:20:54,100 --> 00:20:55,380
당연하죠

379
00:20:55,420 --> 00:20:59,700
스프링 부트 2에 포함될 웹 플럭스에서는

380
00:20:59,800 --> 00:21:02,880
지금 사용하시는 모든 것들이

381
00:21:03,020 --> 00:21:06,540
웹 플럭스에서도 지원됩니다. 액츄에이터는 그중에 아주 핵심이죠

382
00:21:07,160 --> 00:21:11,400
이런 부분의 지원을 위해서 우리는

383
00:21:11,460 --> 00:21:13,960
엔드포인트 API를 확장해야 했는데요

384
00:21:13,960 --> 00:21:17,800
이를 통해 웹 플럭스나 MVC 모두에서 사용할 수 있습니다

385
00:21:17,980 --> 00:21:19,980
긍정적인 부가 효과중 하나는

386
00:21:20,300 --> 00:21:23,380
액츄에이터가 이제 jersey 에서도 동작한다는 것입니다

387
00:21:24,100 --> 00:21:28,640
추가하는 방법은 의존성을 명시해 주면 됩니다

388
00:21:29,360 --> 00:21:31,720
이게 다 입니다

389
00:21:34,640 --> 00:21:38,280
액츄에이터의 엔트포인트에 접근해 보면

390
00:21:41,340 --> 00:21:43,340
많은 정보가 나오진 않네요 / UP

391
00:21:44,740 --> 00:21:48,940
info 에는 우리가 아무것도 추가하지 않았기 때문에 나오는게 없지만

392
00:21:48,940 --> 00:21:50,920
여러분은 애플리케이션의 빌드 정보나

393
00:21:50,940 --> 00:21:53,740
git repo와 같은 정보들을 추가할 수도 있겠습니다

394
00:21:54,620 --> 00:21:57,620
그리고 /env 엔드포인트는 여러분에게

395
00:21:57,740 --> 00:22:01,820
시스템 환경 설정과 같은 추가 정보들을 보여줍니다

396
00:22:02,720 --> 00:22:06,060
여기 지금 404 오류가 보이는 이유는

397
00:22:06,160 --> 00:22:10,100
스프링 부트 2.0의 액츄에이터는

398
00:22:10,100 --> 00:22:11,860
이 기능이 기본으로 꺼져있습니다

399
00:22:12,000 --> 00:22:15,100
이는 보안상의 이유때문이구요

400
00:22:15,260 --> 00:22:19,320
액츄에이터에서 보이는 정보는 때로는 굉장히 민감할 수 있기 때문인데

401
00:22:19,380 --> 00:22:23,260
여러분의 스프링 구동환경에 대한 모든 정보 같은 것들입니다

402
00:22:23,520 --> 00:22:26,980
사고의 가능성을 미연에 방지하기 위해서

403
00:22:26,980 --> 00:22:28,860
기본으로 비활성화 되었습니다

404
00:22:28,980 --> 00:22:34,020
액츄에이터의 엔드포인트에 대한 보안을 강화하는 것이 좋은데요

405
00:22:34,020 --> 00:22:35,940
여기에 스프링 시큐리티를 사용하거나

406
00:22:36,120 --> 00:22:38,600
방화벽 뒤에서 구동하거나

407
00:22:38,600 --> 00:22:40,780
하는 방법들이 사전에 고려되어야 합니다

408
00:22:41,180 --> 00:22:46,780
데모를 위해서 /env 엔드포인트를 활성화 해 보자면

409
00:22:47,300 --> 00:22:50,380
web.expose에 *를 사용하면 됩니다 
(보안상 사용에 유의)

410
00:22:50,380 --> 00:22:51,880
DevTools을 사용하기 때문에

411
00:22:51,920 --> 00:22:55,080
변경사항을 저장하면 애플리케이션이 자동으로 재시작 됩니다

412
00:22:55,080 --> 00:22:59,080
애플리케이션이 재시작되면 /env 엔드포인트 정보를 볼 수 있죠

413
00:23:00,000 --> 00:23:03,520
스프링 부트 2.0의 액츄에이터는 신규 기능들도 포함하는데

414
00:23:03,720 --> 00:23:06,880
출력되는 내용이 보다 풍성해졌습니다

415
00:23:07,120 --> 00:23:11,320
방금 설정한 프로퍼티에 대한 정보를 볼 수 있는데요

416
00:23:11,680 --> 00:23:14,660
/env 뒤에 원하는 프로퍼티 아이디를 입력하면 됩니다

417
00:23:14,900 --> 00:23:21,620
이렇게 제공되는 내용을 통해 스프링 부트 애플리케이션이 참조하는 값들에 대한 정보를 얻을 수 있구요

418
00:23:22,020 --> 00:23:26,960
각각의 프로퍼티가 어디서 설정되었는지를 볼 수도 있습니다

419
00:23:26,960 --> 00:23:28,380
이 경우에는 단 하나죠

420
00:23:29,580 --> 00:23:33,160
그리고 추가된 내용은 오리진에 대한 정보인데

421
00:23:33,160 --> 00:23:35,440
설정 파일의 정확한 어떤 위치에서

422
00:23:35,540 --> 00:23:37,320
값이 설정되었는지 볼 수 있습니다

423
00:23:37,320 --> 00:23:40,660
1:33은 첫번째 라인의 33번째 캐릭터 라고 표시되네요

424
00:23:40,660 --> 00:23:45,080
IDE를 통해 보여 드릴께요

425
00:23:45,320 --> 00:23:50,260
작은 부분이긴 하지만, 새롭게 개선된 부분입니다

426
00:23:50,420 --> 00:23:54,840
이런 도구들이 여러분을 도울 수 있을거라고 생각하구요

427
00:23:54,880 --> 00:24:01,220
오리진 정보를 통해 설정 정보의 참조 위치 파악이 쉬워질 것으로 생각합니다

428
00:24:01,760 --> 00:24:03,760
멋지네요

429
00:24:03,860 --> 00:24:06,420
지금까지 설명드린 내용을 통해

430
00:24:06,420 --> 00:24:10,840
스프링 부트 2.0 과 리액티브 지원에 대해 짧게 살펴 보았습니다

431
00:24:11,220 --> 00:24:13,580
다시 말씀드리지만, 이번 행사에 이런 부분에 대해서

432
00:24:13,600 --> 00:24:16,240
더 자세하게 들으실 수 있는 세션들이 준비되어 있습니다

433
00:24:16,300 --> 00:24:19,980
어, 근데 제 생각에는 뭔가 중요한것을 빠트린것 같아요

434
00:24:19,980 --> 00:24:21,140
그게 뭐죠?

435
00:24:21,300 --> 00:24:24,640
스프링 부트 배너에 대해 소개하지 않았네요

436
00:24:27,060 --> 00:24:30,320
배너의 개선에 대해서 보고싶은 분 계신가요?

437
00:24:30,540 --> 00:24:32,540
[청중 박수로 환호]

438
00:24:32,820 --> 00:24:36,180
한명밖에 없지만 그래도 보여드려야 겠어요

439
00:24:39,100 --> 00:24:42,180
여기 스프링 부트 애플리케이션 하나가 있는데요

440
00:24:42,240 --> 00:24:45,800
스프링 애니메이션.jar 입니다

441
00:24:47,680 --> 00:24:49,680
와우~~~

442
00:24:50,860 --> 00:24:55,700
보시다시피 올해 배너를 개선했습니다

443
00:24:57,700 --> 00:25:01,660
이건 스프링 부트 2 M7 부터 제공될 예정이구요

444
00:25:01,680 --> 00:25:04,380
여러분이 만약 움직이는 gif 파일을

445
00:25:04,460 --> 00:25:09,020
여러분이 알고 계신 위치에 저장하거나 설정에 추가하면

446
00:25:09,040 --> 00:25:11,040
gif의 배너를 만들어 드립니다

447
00:25:11,200 --> 00:25:14,740
제 생각에 여러분 모두 한번씩 테스트 해 보셔야 할 것 같네요

448
00:25:14,740 --> 00:25:16,680
엄청 쿨하고 아주 유용해요

449
00:25:17,680 --> 00:25:22,660
제 생각엔 액츄에이터의 오리진 지원만큼이나 유용하네요, 그렇죠?

450
00:25:23,200 --> 00:25:26,480
그럴수도, 아닐수도 있지만 선택은 여러분의 몫입니다

451
00:25:26,760 --> 00:25:30,400
감사합니다. 그리고 행사를 즐기시길 바랍니다

452
00:25:31,020 --> 00:25:37,520
스프링

